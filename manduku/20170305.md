
#### 2017/03/05 I am Studying
@(til)[JavaScript]

**내장 객체** 
1. 브라우저 객체 모델
- 현재 브라우저 창이나 탭을 표현하기 위한 객체들을 가지고 있음. 주로 브라우저의 히스토리 목록이나 장치의 화면 등을 모델화
```
Window.Document (현재 로드된 웹페이지)
Window.History (브라우저 히스토리에 기록된 웹페이지)
Window.Location (현재 페이지의 url)
...
```

2. 문서 객체 모델 (DOM: Document object Model)
- 현재 페이지를 표현하기 위해 사용되는 객체. 페이지 내의 각 요소들을 위한 개별적인 객체들을 생성
```
document.getElementById('one');
document.lastmodified;
```

3. 전역 자바스크립트 객체
- 자바스크립트 언어가 모델로서 생성해야 할 필요가 있는 것들을 표현 ex) 날짜와 시간 등등..
```
hotel.toUpperCase();
Math.PI;
```
Javascript 언어 자체에 있는 객체들을 사용

**Javascript의 여섯가지 데이터 타입**

1. String
2. Number
3. Boolean
4. Undefined(변수가 선언은 되었지만, 아무런 값이 대입되지 않을 상태일 때 갖는 값)
5. Null(변수 값이 없는 경우, 한 때 어떤 값을 가지고 있었더라도 지금은 아무런 값도 갖지 않은 상태)

내부적으로 자바스크립트는 모든 변수들을 각자의 권한을 가진 객체로 취급. (Undefined, Null은 객체로 표현되지 않는다.)

6. Object
함수 또한 객체이다
함수는 일반 객체들과는 달리 외부로부터 호출이 가능한 특별한 기능이 부여되어 있음

**JS의 비교 연산자**
`==` 동등비교 연산자  - 두 값이 같은 값인지를 비교
`===` 일치 비교 연산자 - 두 값이 서로 같은 데이터 타입의 같은 값을 가지는지 비교 

**타입 강제와 약한 형식화**
자바스크립트가 알지 못하는 데이터 타입을 사용하면 자바스크립트는 오류를 발생시키지 않고, 가능한 작업을 수행하려고 시도한다.

타입 강제(type coercion) - 내부적으로 데이터 타입을 변환하여 작업을 완료 
ex) `'1' > 0` '1'은 숫자 1로 변경되어 `true`가 됨
타입 강제는 코드를 실행하는 도중 이도하지 않은 값을 만들어 낼수 있으므로, `==, !=`보다는 `===, !==`를 사용하는 것이 좋음

**true 혹은 false로 취급되는 값들**
```
var va1 = false;   전형적인 불리언 false
var va2 = 0;    숫자 0
var v3 = '';    NaN(Not a Number, 숫자가 아님)
var v4 = 10/'starbucks';    빈 값
var v5;    값을 대입하지 않은 변수
```

비교 연산자
`OR 연산자`일 때는 true를 리턴할 가능성이 노ㅠ은 코드를 첫번째 조건으로 작성하고, `AND 연산자`일 때는 false를 리턴할 가능성이 높은 코드를 첫 번째 조건으로 작성

**문서 객체 모델(DOM) **
브라우저는 웹 페이지를 로드할 때, 해당 페이지에 대한 모델을 생성.
이 모델을 DOM 트리라고 부르며, 이 모델은 브라우저의 메모리에 저장

노드의 종류 
1. 문서 노드(Document Node)
트리의 최상위에는 문서 노드가 존재하며, 이 노드는 전체 페이지를 표현한다. (브라우저 내에 document 객체로 표현되어 있음)

2. 요소 노드
HTML 요소들은 HTML 페이지의 구조를 서술
ex) `<h1>` `<h6>` `<p>`

3. 특성 노드 
HTML 요소의 여넌 태그에 특성을 지정할 수 있으며, 이런 특성들은 DOM 트리 내에서 특성(attribute) 노드로 표현

4. 텍스트 노드
요소 노드에 접근하면 해당 요소 내부의 텍스트에 접근할 수 있음. 이 텍스트는 해당 요소의 텍스트 노드에 저장 됨.


**DOM Tree 활용**
1. 요소 접근하기
- 하나의 요소 선택하기
```
getElementById() --> 요소의 id 특성 값을 이용
querySelector() --> css 선택자를 이용하여, 일치하는 요소들 중 첫번째 요소를 리턴
```

2. 여러 개의 노드 선택하기(노드 목록)
```
getElementByClassName() --> 지정된 class 특성 값을 가지는 요소들을 모두 리턴
getElementByTagName() --> 지정된 tag 이름을 가지는 요소들을 모두 선택
querySelectorAll() --> 지정된 css 선택자와 일치하는 요소들을 모두 선택
```

3. 요소 노드 사이를 탐색하기
```
parentNode --> 현재 요소 노드의 부모 노드를 선택
previousSibling /nextSibling --> 현재 DOM 트리 내의 이전 또는 다음 형제 요소를 선택
firstChild / lastChild --> 현재 요소의 첫 번째 혹은 마지막 자식 노드를 선택
```

**DOM 쿼리 캐싱**
스크립트가 같은 요소를 한 번 이상 사용해야 할 필요가 있다면 DOM트리를 여러 번 조회하는 것을 방지하기 위해 이 요소들의 위치를 변수에 저장해야 함. 

**공백노드**
IE를 제외한 대부분의 브라우저들은 요소 사이의 공백문자를 텍스트 노드로 취급하기 때문에 아래의 속성들이 리턴하는 값은 브라우저에 따라 달라지게 된다.
```
previousSibling
nextSibling
firstChild
lastChild
```
이러한 문제는 JQuery 라이브러리를 사용하면 알아서 해결해준다.

**HTML 콘텐츠를 추가/제거하기**
- `innerHTML` 속성
1. 새로운 컨텐츠를 문자열로서 변수에 저장
2. 컨텐츠를 수정할 요소를 탐색
3. 요소의 `innerHTML` 속성에 새로운 문자열을 대입
- `DOM` 조작 방식
1. DOM 메서드를 이용하여 새로운 컨텐츠를 생성할 노드를 생성 후 변수에 저장
2. DOM 메서드를 이용하여 적당한 위치에 새로 생성한 노드를 덧붙임

**HTML 콘텐츠를 수정하는 기법**
1. `document.write()`
페이지 원본 소스 코드에 존재하지 않던 컨텐츠를 페이지에 추가할 수 있는 가장 간단한 방법

단점
- 페이지가 로드된 후에만 동작
- 전체 페이지를 덮어 쓴다. 
- 새로운 페이지를 만든다
- 페이지에 컨텐츠를 추가하는 것이 아님


2. `element.innerHTML`
특정 요소의 전체 콘텐츠(마크업 포함)를 가져오거나 수정할 수 있다.

장점 
- DOM 조작 방식에 비해 코드량이 적다
- DOM 조작 방식보다 빠르다
- 쉽게 요소들을 제거할 수 있다

단점
- 사용자로부터 전달받은 콘텐츠를 추가할 때 사용해서는 안됨(보안에 취약)
- DOM의 일부로부터 수정하고자 하는 하나의 요소를 구분하기 어렵다
- 이벤트 핸들러가 의도한 대로 동작하지 않는다

3. DOM 조작 방식
요소와 텍스트 노드에 접근하거나 생성 혹은 수정하기 위해 일련의 메서드와 속성을 이용하는 방식

장점
- 이웃한 요소가 많은 DOM 내에서 특정 요소를 변경하고자 할 때 적합
- 이벤트 핸들러에 아무런 영향을 미치지 않는다
- 스크립트를 통해 점진적으로 요소를 추가하기가 쉽다

단점
- 대량의 컨텐츠를 변경해야 할 경우 `innerHTML` 속성보다 느리다.
- `innerHTML`에 비해 코드 작성량이 많다.
